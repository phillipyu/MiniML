(** A mini-ML
    @author Stuart M. Shieber

    This module implements a small untyped ML-like language under
    various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct *)
exception EvalException ;;

module type Env_type = sig
    type env
    type value =
       | Val of expr
       | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value =
      Closure (exp, env);;

    (* Looks up the value of a variable in the environment *)
    let rec lookup (env: env) (varname: varid) : value =
      match env with
      | [] -> raise (EvalError "variable not found")
      | (key, v)::tl -> 
        if key = varname then !v 
        else lookup tl varname

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let rec extend (env: env) (varname: varid) (loc: value ref) : env =
      match env with
      | [] -> [(varname, loc)]
      | (key, v)::tl -> 
        if key = varname then (varname, loc)::tl
        else (key, v)::extend tl varname loc

    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
      match env with 
      | [] -> ""
      | (key, v)::tl -> 
        "(" ^ key ^ ", " ^ value_to_string !v ^ "); " ^ env_to_string tl
    
    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with
      | Val exp -> exp_to_string exp
      | Closure (exp, env) -> 
          "(" ^ exp_to_string exp ^ ", " ^ env_to_string env ^ ")"
  end
;;
  
(* Functions to evaluate binary and unary operators *)
let binopeval (op: varid) (v1: expr) (v2: expr) : expr =
  match op, v1, v2 with
  | "+", Num x1, Num x2 -> Num (x1 + x2)
  | "+", _, _ ->
      raise (EvalError "can't add non-nums")
  | "-", Num x1, Num x2 -> Num (x1 - x2)
  | "-", _, _ ->
      raise (EvalError "can't subtract non-nums")
  | "*", Num x1, Num x2 -> Num (x1 * x2)
  | "*", _, _ ->
      raise (EvalError "can't mult non-nums")
  | "=", x1, x2 -> Bool (x1 = x2)
  | "<", Num x1, Num x2 -> Bool (x1 < x2)
  | "<", _, _ ->
      raise (EvalError "can't evaluate non-nums")
  | _, _, _ -> 
      raise (EvalError "binop not supported")

let unopeval (op: varid) (v1: expr) : expr = 
  match op, v1 with
  | "~", Num x1 -> Num (~- x1)
  | "~", _ ->
      raise (EvalError "can't negate non-nums")
  | _, _ ->
      raise (EvalError "unop not supported")

(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)
let eval_t exp _env = Env.Val exp ;;

let eval_s (exp : expr) _env : Env.value = 
  let rec eval_s_help (exp: expr) : expr =
    match exp with 
    | Num _ | Bool _ -> exp 
    | Var x -> raise (EvalError "unbound variable")
    | Conditional (x, y, z) -> 
        if eval_s_help (Binop ("=", x, Bool true)) = Bool true then
          eval_s_help y 
        else eval_s_help z 
    | Unop (op, y) -> unopeval op (eval_s_help y)
    | Binop (op, y, z) -> binopeval op (eval_s_help y) (eval_s_help z)
    | App (func, arg) ->  
      (match eval_s_help func with 
      | Fun (x, y) -> eval_s_help (subst x (eval_s_help arg) (y))
      | _ -> raise (EvalError "non-function cannot be applied"))
    | Fun (x, y) -> Fun (x, y)
    | Let (x, def, body) -> 
        eval_s_help (subst x (eval_s_help def) body)
    | Letrec (x, def, body) -> 
        let rec1 = eval_s_help (subst x (Letrec (x, def, Var x)) def) in
        eval_s_help (subst x rec1 body)
    | Raise -> raise EvalException
    | Unassigned -> Unassigned
  in Env.Val (eval_s_help exp)
;;

let rec eval_dl (exp: expr) (env: Env.env) (n: string) : Env.value = 
  match exp with 
    | Num _ | Bool _ -> Env.Val exp 
    | Var x -> Env.lookup env x
    | Conditional (x, y, z) -> 
        if eval_dl (Binop ("=", x, Bool true)) env n = Env.Val (Bool true) then
          eval_dl y env n
        else eval_dl z env n
    | Unop (op, y) -> 
      (match eval_dl y env n with
      | Env.Val x -> Env.Val (unopeval op x)
      | _ -> raise (EvalError "closure found: invariant violated"))
    | Binop (op, y, z) -> 
      (match eval_dl y env n, eval_dl z env n with
      | Env.Val a, Env.Val b -> Env.Val (binopeval op a b)
      | _, _ -> raise (EvalError "closure found: invariant violated")) 
    | App (func, arg) ->  
      (match n, eval_dl func env n with 
      | "d", Env.Val (Fun (x, y)) -> 
          eval_dl y (Env.extend env x (ref (eval_dl arg env n))) n
      | "l", Env.Closure (Fun (x, y), env') -> 
          eval_dl y (Env.extend env' x (ref (eval_dl arg env n))) n
      | _ -> raise (EvalError "non-function cannot be applied"))
    | Fun (x, y) -> 
        if n = "d" then
          Env.Val (Fun (x, y))
        else Env.Closure (Fun (x, y), env)
    | Let (x, def, body) -> 
        eval_dl body (Env.extend env x (ref (eval_dl def env n))) n
    | Letrec (x, def, body) -> 
        let value = ref (Env.Val Unassigned) in
        let env' = Env.extend env x value in
        let q' = eval_dl def env' n in
        value := q'; 
        eval_dl body env' n
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError "unbound variable")

let eval_d (exp: expr) (env: Env.env) : Env.value = 
  eval_dl exp env "d"

let rec eval_l (exp: expr) (env: Env.env) : Env.value = 
  eval_dl exp env "l"

let evaluate = eval_l ;;
